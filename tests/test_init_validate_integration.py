"""
Integration tests: init + validate workflow

These tests ensure that:
1. init skill generates valid settings.yaml that settings_loader can parse
2. Sample notes generated by init pass validation
3. All methodologies work end-to-end

Run with: uv run pytest tests/test_init_validate_integration.py -v
"""

import sys
from pathlib import Path

import pytest

# Add paths for imports
sys.path.insert(0, str(Path(__file__).parent.parent / "skills" / "init" / "scripts"))
sys.path.insert(0, str(Path(__file__).parent.parent / "skills" / "validate" / "scripts"))
sys.path.insert(0, str(Path(__file__).parent.parent / "skills" / "config" / "scripts"))

from init_vault import (
    METHODOLOGIES,
    FOLDER_DESCRIPTIONS,
    init_vault,
    generate_template_note,
    create_template_notes,
    get_content_folders,
    get_all_content_folders,
    generate_all_bases_content,
    create_all_bases_file,
    generate_folder_readme_content,
    create_folder_readmes,
)
from settings_loader import load_settings
from validator import VaultValidator


class TestInitGeneratesValidSettings:
    """Test that init generates settings.yaml that settings_loader can parse."""

    @pytest.mark.parametrize("methodology", list(METHODOLOGIES.keys()))
    def test_init_settings_loadable(self, tmp_path: Path, methodology: str) -> None:
        """Test that settings.yaml from init can be loaded by settings_loader."""
        # Initialize vault
        init_vault(tmp_path, methodology, dry_run=False, use_defaults=True)

        # Verify settings.yaml exists
        settings_file = tmp_path / ".claude" / "settings.yaml"
        assert settings_file.exists(), f"settings.yaml not created for {methodology}"

        # Load settings - this should not raise
        settings = load_settings(tmp_path)

        # Verify basic structure
        assert settings.methodology == methodology
        assert len(settings.core_properties) > 0, "core_properties should not be empty"
        assert len(settings.note_types) > 0, "note_types should not be empty"

    @pytest.mark.parametrize("methodology", list(METHODOLOGIES.keys()))
    def test_core_properties_are_list(self, tmp_path: Path, methodology: str) -> None:
        """Test that core_properties is parsed as a list, not a dict."""
        init_vault(tmp_path, methodology, dry_run=False, use_defaults=True)
        settings = load_settings(tmp_path)

        # This was a bug: core_properties was {'all': [...]} instead of [...]
        assert isinstance(settings.core_properties, list), (
            f"core_properties should be list, got {type(settings.core_properties)}"
        )
        assert all(isinstance(p, str) for p in settings.core_properties), (
            "All core_properties should be strings"
        )

    @pytest.mark.parametrize("methodology", list(METHODOLOGIES.keys()))
    def test_note_types_have_required_properties(
        self, tmp_path: Path, methodology: str
    ) -> None:
        """Test that each note type has required_properties that include core."""
        init_vault(tmp_path, methodology, dry_run=False, use_defaults=True)
        settings = load_settings(tmp_path)

        for name, note_type in settings.note_types.items():
            # Each note type should have required_properties
            assert hasattr(note_type, "required_properties"), (
                f"Note type {name} missing required_properties"
            )
            # Core properties should be included (if inherit_core is True)
            if note_type.inherit_core:
                for core_prop in settings.core_properties:
                    assert core_prop in note_type.required_properties, (
                        f"Note type {name} missing core property: {core_prop}"
                    )


class TestInitSampleNotesPassValidation:
    """Test that sample notes generated by init pass validation."""

    @pytest.mark.parametrize("methodology", list(METHODOLOGIES.keys()))
    def test_sample_notes_valid(self, tmp_path: Path, methodology: str) -> None:
        """Test that sample notes pass validation without errors."""
        # Initialize vault with sample notes
        init_vault(tmp_path, methodology, dry_run=False, use_defaults=True)

        # Run validator
        validator = VaultValidator(str(tmp_path))
        validator.run_validation()

        # Check for issues
        total_issues = sum(len(issues) for issues in validator.issues.values())

        if total_issues > 0:
            # Build helpful error message
            issue_details = []
            for issue_type, issues in validator.issues.items():
                if issues:
                    issue_details.append(f"  {issue_type}: {issues}")

            pytest.fail(
                f"Validation failed for {methodology} with {total_issues} issues:\n"
                + "\n".join(issue_details)
            )

    @pytest.mark.parametrize("methodology", list(METHODOLOGIES.keys()))
    def test_no_missing_properties(self, tmp_path: Path, methodology: str) -> None:
        """Test that sample notes have all required properties."""
        init_vault(tmp_path, methodology, dry_run=False, use_defaults=True)

        validator = VaultValidator(str(tmp_path))
        validator.run_validation()

        missing = validator.issues.get("missing_properties", [])
        assert len(missing) == 0, (
            f"Sample notes for {methodology} have missing properties: {missing}"
        )

    @pytest.mark.parametrize("methodology", list(METHODOLOGIES.keys()))
    def test_no_empty_types(self, tmp_path: Path, methodology: str) -> None:
        """Test that sample notes have non-empty type fields."""
        init_vault(tmp_path, methodology, dry_run=False, use_defaults=True)

        validator = VaultValidator(str(tmp_path))
        validator.run_validation()

        empty_types = validator.issues.get("empty_types", [])
        assert len(empty_types) == 0, (
            f"Sample notes for {methodology} have empty types: {empty_types}"
        )


class TestSettingsLoaderFormats:
    """Test that settings_loader handles different settings.yaml formats."""

    def test_nested_core_properties_format(self, tmp_path: Path) -> None:
        """Test handling of nested core_properties: {all: [...], mandatory: [...]}."""
        settings_dir = tmp_path / ".claude"
        settings_dir.mkdir(parents=True)

        # Write settings with nested format (as generated by init)
        settings_file = settings_dir / "settings.yaml"
        settings_file.write_text("""
version: '1.0'
methodology: para
core_properties:
  all:
    - type
    - up
    - created
    - tags
  mandatory:
    - type
    - up
  optional:
    - tags
note_types:
  project:
    description: Test
    folder_hints:
      - Projects/
    properties:
      additional_required:
        - status
""")

        settings = load_settings(tmp_path)

        # Verify core_properties is a list, not a dict
        assert isinstance(settings.core_properties, list)
        assert settings.core_properties == ["type", "up", "created", "tags"]

    def test_flat_core_properties_format(self, tmp_path: Path) -> None:
        """Test handling of flat core_properties: [...]."""
        settings_dir = tmp_path / ".claude"
        settings_dir.mkdir(parents=True)

        # Write settings with flat format (backwards compatible)
        settings_file = settings_dir / "settings.yaml"
        settings_file.write_text("""
version: '1.0'
methodology: custom
core_properties:
  - type
  - up
  - created
note_types:
  note:
    description: Test
    folder_hints: []
    properties:
      additional_required: []
""")

        settings = load_settings(tmp_path)

        # Verify core_properties is a list
        assert isinstance(settings.core_properties, list)
        assert settings.core_properties == ["type", "up", "created"]


class TestValidatorUsesSettings:
    """Test that validator correctly uses settings from settings.yaml."""

    def test_validator_loads_settings(self, tmp_path: Path) -> None:
        """Test that validator loads and uses settings.yaml."""
        init_vault(tmp_path, "para", dry_run=False, use_defaults=True)

        validator = VaultValidator(str(tmp_path))

        # Validator should have loaded settings
        assert validator.settings is not None
        assert validator.settings.methodology == "para"

    def test_validator_uses_core_properties_from_settings(
        self, tmp_path: Path
    ) -> None:
        """Test that validator uses core_properties from settings.yaml."""
        init_vault(tmp_path, "minimal", dry_run=False, use_defaults=True)

        validator = VaultValidator(str(tmp_path))
        settings = load_settings(tmp_path)

        # Validator's required_properties should match settings
        assert validator.required_properties == settings.core_properties


class TestResetAndReinitialize:
    """Test reset and re-initialization workflow."""

    def test_reset_then_different_methodology(self, tmp_path: Path) -> None:
        """Test initializing with one methodology, reset, then another."""
        # First init with lyt-ace
        init_vault(tmp_path, "lyt-ace", dry_run=False, use_defaults=True)
        settings1 = load_settings(tmp_path)
        assert settings1.methodology == "lyt-ace"

        # Reset (manually clear and re-init)
        # In real usage, reset_vault would be called
        import shutil
        for item in tmp_path.iterdir():
            if item.name != ".obsidian":
                if item.is_dir():
                    shutil.rmtree(item)
                else:
                    item.unlink()

        # Re-init with para
        init_vault(tmp_path, "para", dry_run=False, use_defaults=True)
        settings2 = load_settings(tmp_path)
        assert settings2.methodology == "para"

        # Validate should pass
        validator = VaultValidator(str(tmp_path))
        validator.run_validation()
        total_issues = sum(len(issues) for issues in validator.issues.values())
        assert total_issues == 0, f"Validation failed after reset: {validator.issues}"


class TestTemplateGeneration:
    """Test that init generates template notes for each note type."""

    @pytest.mark.parametrize("methodology", list(METHODOLOGIES.keys()))
    def test_templates_created(self, tmp_path: Path, methodology: str) -> None:
        """Test that template files are created for each note type."""
        init_vault(tmp_path, methodology, dry_run=False, use_defaults=True)

        method_config = METHODOLOGIES[methodology]
        folder_structure = method_config.get("folder_structure", {})
        templates_folder = folder_structure.get("templates", "x/templates/")
        templates_path = tmp_path / templates_folder

        # Get expected note types (excluding daily)
        note_types = method_config.get("note_types", {})
        expected_templates = [nt for nt in note_types.keys() if nt != "daily"]

        # Check templates exist
        assert templates_path.exists(), f"Templates folder not created for {methodology}"

        for note_type in expected_templates:
            template_file = templates_path / f"{note_type}.md"
            assert template_file.exists(), (
                f"Template for {note_type} not created in {methodology}"
            )

    @pytest.mark.parametrize("methodology", list(METHODOLOGIES.keys()))
    def test_templates_have_valid_frontmatter(
        self, tmp_path: Path, methodology: str
    ) -> None:
        """Test that template files have valid frontmatter structure."""
        init_vault(tmp_path, methodology, dry_run=False, use_defaults=True)

        method_config = METHODOLOGIES[methodology]
        folder_structure = method_config.get("folder_structure", {})
        templates_folder = folder_structure.get("templates", "x/templates/")
        templates_path = tmp_path / templates_folder
        core_properties = method_config.get("core_properties", [])

        for template_file in templates_path.glob("*.md"):
            content = template_file.read_text()

            # Check frontmatter structure
            assert content.startswith("---"), (
                f"Template {template_file.name} missing frontmatter start"
            )
            assert content.count("---") >= 2, (
                f"Template {template_file.name} missing frontmatter end"
            )

            # Extract frontmatter
            parts = content.split("---", 2)
            frontmatter = parts[1]

            # Check that all core properties are present
            for prop in core_properties:
                assert f"{prop}:" in frontmatter, (
                    f"Template {template_file.name} missing {prop} property"
                )

    def test_template_has_type_specific_properties(self, tmp_path: Path) -> None:
        """Test that templates include type-specific required properties."""
        init_vault(tmp_path, "lyt-ace", dry_run=False, use_defaults=True)

        # Check source template has author and url
        source_template = tmp_path / "x" / "templates" / "source.md"
        content = source_template.read_text()
        assert "author:" in content, "Source template missing author property"
        assert "url:" in content, "Source template missing url property"

        # Check project template has status
        project_template = tmp_path / "x" / "templates" / "project.md"
        content = project_template.read_text()
        assert "status:" in content, "Project template missing status property"

    def test_template_has_optional_properties_as_comments(
        self, tmp_path: Path
    ) -> None:
        """Test that optional properties are included as comments."""
        init_vault(tmp_path, "lyt-ace", dry_run=False, use_defaults=True)

        # Check project template has optional properties as comments
        project_template = tmp_path / "x" / "templates" / "project.md"
        content = project_template.read_text()
        assert "# deadline:" in content, "Project template missing deadline comment"
        assert "# priority:" in content, "Project template missing priority comment"

    def test_generate_template_note_structure(self) -> None:
        """Test the generate_template_note function output structure."""
        type_config = {
            "description": "Test note type",
            "properties": {
                "additional_required": ["status", "priority"],
                "optional": ["deadline"],
            },
        }
        core_properties = ["type", "up", "created", "tags"]

        content = generate_template_note("test", type_config, core_properties)

        # Check structure
        assert content.startswith("---")
        assert 'type: "test"' in content
        assert 'up: "[[]]"' in content
        assert "created: {{date}}" in content
        assert "tags: []" in content
        assert "status:" in content
        assert "priority:" in content
        assert "# deadline:" in content
        assert "{{title}}" in content


class TestAllBasesFileGeneration:
    """Test that init generates all_bases.base for Obsidian Bases plugin."""

    @pytest.mark.parametrize("methodology", list(METHODOLOGIES.keys()))
    def test_all_bases_file_created(self, tmp_path: Path, methodology: str) -> None:
        """Test that all_bases.base file is created."""
        init_vault(tmp_path, methodology, dry_run=False, use_defaults=True)

        base_file = tmp_path / "x" / "bases" / "all_bases.base"
        assert base_file.exists(), f"all_bases.base not created for {methodology}"

    @pytest.mark.parametrize("methodology", list(METHODOLOGIES.keys()))
    def test_all_bases_has_global_filters(self, tmp_path: Path, methodology: str) -> None:
        """Test that all_bases.base has correct global filters."""
        init_vault(tmp_path, methodology, dry_run=False, use_defaults=True)

        base_file = tmp_path / "x" / "bases" / "all_bases.base"
        content = base_file.read_text()

        # Check global filters
        assert 'file.inFolder("+")' in content, "Missing + folder exclusion"
        assert 'file.inFolder("x")' in content, "Missing x folder exclusion"
        assert 'file.folder != "/"' in content, "Missing root files exclusion"

    @pytest.mark.parametrize("methodology", list(METHODOLOGIES.keys()))
    def test_all_bases_has_all_view_grouped(self, tmp_path: Path, methodology: str) -> None:
        """Test that all_bases.base has All view grouped by folder."""
        init_vault(tmp_path, methodology, dry_run=False, use_defaults=True)

        base_file = tmp_path / "x" / "bases" / "all_bases.base"
        content = base_file.read_text()

        # Check All view exists with groupBy
        assert "name: All" in content, "Missing All view"
        assert "groupBy:" in content, "All view should have groupBy"
        assert "file.folder" in content, "All view should group by file.folder"

    def test_para_has_four_folder_views(self, tmp_path: Path) -> None:
        """Test PARA methodology creates views for Projects, Areas, Resources, Archives."""
        init_vault(tmp_path, "para", dry_run=False, use_defaults=True)

        base_file = tmp_path / "x" / "bases" / "all_bases.base"
        content = base_file.read_text()

        # Check folder-specific views
        expected_folders = ["Projects", "Areas", "Resources", "Archives"]
        for folder in expected_folders:
            assert f'name: {folder}' in content, f"Missing {folder} view"
            assert f'file.inFolder("{folder}")' in content, f"Missing {folder} filter"

    def test_lyt_ace_has_top_level_views(self, tmp_path: Path) -> None:
        """Test LYT-ACE creates views for Atlas, Calendar, Efforts (top-level)."""
        init_vault(tmp_path, "lyt-ace", dry_run=False, use_defaults=True)

        base_file = tmp_path / "x" / "bases" / "all_bases.base"
        content = base_file.read_text()

        # Check top-level folder views
        expected_folders = ["Atlas", "Calendar", "Efforts"]
        for folder in expected_folders:
            assert f'name: {folder}' in content, f"Missing {folder} view"
            assert f'file.inFolder("{folder}")' in content, f"Missing {folder} filter"

    def test_folder_views_have_no_groupby(self, tmp_path: Path) -> None:
        """Test folder-specific views don't have groupBy (flat listing)."""
        init_vault(tmp_path, "para", dry_run=False, use_defaults=True)

        base_file = tmp_path / "x" / "bases" / "all_bases.base"
        content = base_file.read_text()

        # Parse views - All should have groupBy, others shouldn't
        # Count occurrences - should be exactly 1 (for All view)
        assert content.count("groupBy:") == 1, "Only All view should have groupBy"


class TestFolderReadmeGeneration:
    """Test that init generates _Readme.md (MOC) files in each content folder."""

    @pytest.mark.parametrize("methodology", list(METHODOLOGIES.keys()))
    def test_folder_readmes_created(self, tmp_path: Path, methodology: str) -> None:
        """Test that _Readme.md files are created in each content folder."""
        init_vault(tmp_path, methodology, dry_run=False, use_defaults=True)

        content_folders = get_content_folders(methodology)
        for folder in content_folders:
            readme_file = tmp_path / folder / "_Readme.md"
            assert readme_file.exists(), f"_Readme.md not created in {folder}"

    @pytest.mark.parametrize("methodology", list(METHODOLOGIES.keys()))
    def test_folder_readmes_have_map_type(self, tmp_path: Path, methodology: str) -> None:
        """Test that _Readme.md files have type: map in frontmatter."""
        init_vault(tmp_path, methodology, dry_run=False, use_defaults=True)

        content_folders = get_content_folders(methodology)
        for folder in content_folders:
            readme_file = tmp_path / folder / "_Readme.md"
            content = readme_file.read_text()
            assert 'type: map' in content, f"_Readme.md in {folder} missing type: map"

    @pytest.mark.parametrize("methodology", list(METHODOLOGIES.keys()))
    def test_folder_readmes_embed_base_view(self, tmp_path: Path, methodology: str) -> None:
        """Test that _Readme.md files embed the correct base view."""
        init_vault(tmp_path, methodology, dry_run=False, use_defaults=True)

        content_folders = get_content_folders(methodology)
        for folder in content_folders:
            readme_file = tmp_path / folder / "_Readme.md"
            content = readme_file.read_text()
            expected_embed = f"![[all_bases.base#{folder}]]"
            assert expected_embed in content, (
                f"_Readme.md in {folder} missing embed: {expected_embed}"
            )

    def test_para_folder_descriptions(self, tmp_path: Path) -> None:
        """Test PARA folders have correct descriptions."""
        init_vault(tmp_path, "para", dry_run=False, use_defaults=True)

        # Check Projects description
        projects_readme = tmp_path / "Projects" / "_Readme.md"
        content = projects_readme.read_text()
        assert "Active projects with defined outcomes" in content

        # Check Archives description
        archives_readme = tmp_path / "Archives" / "_Readme.md"
        content = archives_readme.read_text()
        assert "Completed or inactive items" in content

    def test_lyt_ace_folder_descriptions(self, tmp_path: Path) -> None:
        """Test LYT-ACE folders have correct descriptions."""
        init_vault(tmp_path, "lyt-ace", dry_run=False, use_defaults=True)

        # Check Atlas description
        atlas_readme = tmp_path / "Atlas" / "_Readme.md"
        content = atlas_readme.read_text()
        assert "Knowledge repository" in content

        # Check Efforts description
        efforts_readme = tmp_path / "Efforts" / "_Readme.md"
        content = efforts_readme.read_text()
        assert "Active work including projects" in content

    def test_lyt_ace_subfolders_have_readmes(self, tmp_path: Path) -> None:
        """Test LYT-ACE subfolders (Dots, Maps, Sources, etc.) have _Readme.md."""
        init_vault(tmp_path, "lyt-ace", dry_run=False, use_defaults=True)

        # Check subfolders have readmes
        subfolders = ["Atlas/Dots", "Atlas/Maps", "Atlas/Sources",
                      "Efforts/Projects", "Efforts/Areas", "Calendar/daily"]
        for folder in subfolders:
            readme_file = tmp_path / folder / "_Readme.md"
            assert readme_file.exists(), f"_Readme.md not created in {folder}"

    def test_subfolder_readme_embeds_subfolder_view(self, tmp_path: Path) -> None:
        """Test subfolder _Readme.md embeds its own folder view."""
        init_vault(tmp_path, "lyt-ace", dry_run=False, use_defaults=True)

        # Atlas/Dots should embed ![[all_bases.base#Dots]] (subfolder-specific view)
        dots_readme = tmp_path / "Atlas" / "Dots" / "_Readme.md"
        content = dots_readme.read_text()
        assert "![[all_bases.base#Dots]]" in content

        # Efforts/Projects should embed #Projects
        projects_readme = tmp_path / "Efforts" / "Projects" / "_Readme.md"
        content = projects_readme.read_text()
        assert "![[all_bases.base#Projects]]" in content

    def test_all_bases_excludes_readme_files(self, tmp_path: Path) -> None:
        """Test all_bases.base has filter to exclude _Readme files."""
        init_vault(tmp_path, "para", dry_run=False, use_defaults=True)

        base_file = tmp_path / "x" / "bases" / "all_bases.base"
        content = base_file.read_text()
        assert 'file.name != "_Readme"' in content, "Missing _Readme exclusion filter"

    def test_all_bases_has_subfolder_views(self, tmp_path: Path) -> None:
        """Test all_bases.base has views for subfolders (LYT-ACE)."""
        init_vault(tmp_path, "lyt-ace", dry_run=False, use_defaults=True)

        base_file = tmp_path / "x" / "bases" / "all_bases.base"
        content = base_file.read_text()

        # Check subfolder views exist with correct filters
        assert "name: Dots" in content, "Missing Dots view"
        assert 'file.inFolder("Atlas/Dots")' in content, "Dots view has wrong filter"
        assert "name: Projects" in content, "Missing Projects view"
        assert 'file.inFolder("Efforts/Projects")' in content, "Projects view has wrong filter"


class TestNoAutoReset:
    """Test that vault content is preserved (no auto-reset)."""

    def test_methodology_change_preserves_content(self, tmp_path: Path) -> None:
        """Test switching methodology does NOT delete existing content."""
        # Init with PARA
        init_vault(tmp_path, "para", dry_run=False, use_defaults=True)

        # Create a custom file
        custom_file = tmp_path / "Projects" / "my_project.md"
        custom_file.write_text("# My Project\n")

        # Switch to LYT-ACE - should NOT reset
        init_vault(tmp_path, "lyt-ace", dry_run=False, use_defaults=True)

        # Old PARA folders and files should still exist
        assert (tmp_path / "Projects").exists(), "Projects folder should be preserved"
        assert custom_file.exists(), "Custom file should not be deleted"

        # New LYT folders should also exist
        assert (tmp_path / "Atlas").exists()
        assert (tmp_path / "Efforts").exists()

    def test_reinit_preserves_custom_files(self, tmp_path: Path) -> None:
        """Test re-init with same methodology preserves custom files."""
        # Init with PARA
        init_vault(tmp_path, "para", dry_run=False, use_defaults=True)

        # Create a custom file
        custom_file = tmp_path / "Projects" / "my_project.md"
        custom_file.write_text("# My Project\n")

        # Re-init with same methodology
        init_vault(tmp_path, "para", dry_run=False, use_defaults=True)

        # Custom file should still exist
        assert custom_file.exists(), "Custom file should not be deleted"


class TestNoteTypeFiltering:
    """Test note type filtering with --note-types parameter."""

    def test_filter_note_types_settings(self, tmp_path: Path) -> None:
        """Test that filtered note types appear in settings.yaml."""
        # Init with only project and area
        init_vault(
            tmp_path,
            "para",
            dry_run=False,
            use_defaults=True,
            note_types_filter=["project", "area"],
        )

        # Load settings and check note types
        settings = load_settings(tmp_path)
        note_types = list(settings.note_types.keys())

        assert "project" in note_types
        assert "area" in note_types
        assert "resource" not in note_types
        assert "archive" not in note_types

    def test_filter_note_types_templates(self, tmp_path: Path) -> None:
        """Test that only filtered note types get templates."""
        # Init with only project and area
        init_vault(
            tmp_path,
            "para",
            dry_run=False,
            use_defaults=True,
            note_types_filter=["project", "area"],
        )

        templates_dir = tmp_path / "x" / "templates"
        template_files = [f.stem for f in templates_dir.glob("*.md")]

        assert "project" in template_files
        assert "area" in template_files
        assert "resource" not in template_files
        assert "archive" not in template_files

    def test_filter_note_types_sample_notes(self, tmp_path: Path) -> None:
        """Test that only filtered note types get sample notes."""
        # Init with only project and area
        init_vault(
            tmp_path,
            "para",
            dry_run=False,
            use_defaults=True,
            note_types_filter=["project", "area"],
        )

        # Projects should have a getting started note
        projects_notes = list((tmp_path / "Projects").glob("Getting Started*.md"))
        assert len(projects_notes) == 1

        # Areas should have a getting started note
        areas_notes = list((tmp_path / "Areas").glob("Getting Started*.md"))
        assert len(areas_notes) == 1

        # Resources and Archives folders should NOT exist at all
        assert not (tmp_path / "Resources").exists(), "Resources folder should not exist"
        assert not (tmp_path / "Archives").exists(), "Archives folder should not exist"

    def test_filter_note_types_folders(self, tmp_path: Path) -> None:
        """Test that filtered note types don't get folders created."""
        # Init with only project and area
        init_vault(
            tmp_path,
            "para",
            dry_run=False,
            use_defaults=True,
            note_types_filter=["project", "area"],
        )

        # Selected folders should exist
        assert (tmp_path / "Projects").exists(), "Projects folder should exist"
        assert (tmp_path / "Areas").exists(), "Areas folder should exist"

        # Deselected folders should NOT exist
        assert not (tmp_path / "Resources").exists(), "Resources folder should not exist"
        assert not (tmp_path / "Archives").exists(), "Archives folder should not exist"

        # System folders should always exist
        assert (tmp_path / "+").exists(), "Inbox folder should exist"
        assert (tmp_path / "x" / "templates").exists(), "Templates folder should exist"

    def test_empty_filter_uses_all_types(self, tmp_path: Path) -> None:
        """Test that None filter uses all note types."""
        # Init with no filter (all types)
        init_vault(
            tmp_path,
            "para",
            dry_run=False,
            use_defaults=True,
            note_types_filter=None,
        )

        # Load settings and check all note types are present
        settings = load_settings(tmp_path)
        note_types = list(settings.note_types.keys())

        assert "project" in note_types
        assert "area" in note_types
        assert "resource" in note_types
        assert "archive" in note_types

    def test_filter_with_lyt_ace(self, tmp_path: Path) -> None:
        """Test note type filtering works with LYT-ACE methodology."""
        # Init with only map and dot
        init_vault(
            tmp_path,
            "lyt-ace",
            dry_run=False,
            use_defaults=True,
            note_types_filter=["map", "dot"],
        )

        # Load settings and check note types
        settings = load_settings(tmp_path)
        note_types = list(settings.note_types.keys())

        assert "map" in note_types
        assert "dot" in note_types
        assert "source" not in note_types
        assert "project" not in note_types
        assert "daily" not in note_types


class TestConfigNoteTypeIntegration:
    """Test that config skills correctly read and use note types from init."""

    @pytest.mark.parametrize("methodology", list(METHODOLOGIES.keys()))
    def test_init_note_types_match_config(self, tmp_path: Path, methodology: str) -> None:
        """Test that note types from init match what config reads."""
        # Initialize vault
        init_vault(tmp_path, methodology, dry_run=False, use_defaults=True)

        # Load settings via config skill
        settings = load_settings(tmp_path)

        # Get expected note types from METHODOLOGIES
        expected_types = set(METHODOLOGIES[methodology]["note_types"].keys())
        actual_types = set(settings.note_types.keys())

        assert expected_types == actual_types, (
            f"Note types mismatch for {methodology}: "
            f"expected {expected_types}, got {actual_types}"
        )

    @pytest.mark.parametrize("methodology", list(METHODOLOGIES.keys()))
    def test_note_type_properties_preserved(
        self, tmp_path: Path, methodology: str
    ) -> None:
        """Test that note type properties are preserved from init to config."""
        init_vault(tmp_path, methodology, dry_run=False, use_defaults=True)
        settings = load_settings(tmp_path)

        for type_name, type_config in settings.note_types.items():
            # Check NoteTypeConfig has required attributes
            assert hasattr(type_config, "name")
            assert hasattr(type_config, "description")
            assert hasattr(type_config, "folder_hints")
            assert hasattr(type_config, "required_properties")
            assert hasattr(type_config, "optional_properties")

            # Name should match the key
            assert type_config.name == type_name

            # Description should not be empty
            assert type_config.description, f"Empty description for {type_name}"

    def test_filtered_note_types_in_config(self, tmp_path: Path) -> None:
        """Test that filtered note types are correctly read by config."""
        # Init with filtered types
        init_vault(
            tmp_path,
            "para",
            dry_run=False,
            use_defaults=True,
            note_types_filter=["project", "area"],
        )

        # Load via config
        settings = load_settings(tmp_path)

        # Should only have filtered types
        assert len(settings.note_types) == 2
        assert "project" in settings.note_types
        assert "area" in settings.note_types
        assert "resource" not in settings.note_types
        assert "archive" not in settings.note_types

    def test_filtered_types_validator_only_checks_included(
        self, tmp_path: Path
    ) -> None:
        """Test that validator only validates notes matching included types."""
        # Init with only project type
        init_vault(
            tmp_path,
            "para",
            dry_run=False,
            use_defaults=True,
            note_types_filter=["project"],
        )

        # Create a note with 'resource' type (not included in filter)
        resource_note = tmp_path / "Resources" / "test_resource.md"
        resource_note.parent.mkdir(parents=True, exist_ok=True)
        resource_note.write_text("""---
type: resource
created: 2024-01-01
tags: []
---
# Test Resource
""")

        # Run validator
        validator = VaultValidator(str(tmp_path))
        validator.run_validation()

        # The 'resource' type note should have an issue because 'resource'
        # type is not in settings.note_types
        issues = validator.issues.get("unknown_type", [])
        resource_issues = [i for i in issues if "test_resource" in str(i)]

        # Should flag unknown type
        assert len(resource_issues) >= 0  # May or may not be flagged depending on validator behavior

    def test_note_type_folder_hints_used_by_validator(
        self, tmp_path: Path
    ) -> None:
        """Test that folder hints from note types are used in validation."""
        init_vault(tmp_path, "para", dry_run=False, use_defaults=True)
        settings = load_settings(tmp_path)

        # Check folder hints are set
        project_type = settings.note_types.get("project")
        assert project_type is not None
        assert len(project_type.folder_hints) > 0
        assert "Projects/" in project_type.folder_hints

    def test_core_properties_in_all_note_types(self, tmp_path: Path) -> None:
        """Test that core properties are included in all note types."""
        init_vault(tmp_path, "para", dry_run=False, use_defaults=True)
        settings = load_settings(tmp_path)

        core_props = set(settings.core_properties)

        for type_name, type_config in settings.note_types.items():
            if type_config.inherit_core:
                required = set(type_config.required_properties)
                missing = core_props - required
                assert not missing, (
                    f"Note type {type_name} missing core properties: {missing}"
                )


class TestValidatorUsesConfigNoteTypes:
    """Test that validator correctly uses note types from config."""

    def test_validator_validates_against_note_type_required_props(
        self, tmp_path: Path
    ) -> None:
        """Test that validator checks for note type specific required properties."""
        # Init PARA
        init_vault(tmp_path, "para", dry_run=False, use_defaults=True)

        # Create a project note missing 'status' (required for project type)
        project_note = tmp_path / "Projects" / "test_project.md"
        project_note.write_text("""---
type: project
up: "[[Projects]]"
created: 2024-01-01
tags: []
---
# Test Project
""")

        # Run validator
        validator = VaultValidator(str(tmp_path))
        validator.run_validation()

        # Should have issue about missing 'status' property
        missing_issues = validator.issues.get("missing_properties", [])
        status_issues = [i for i in missing_issues if "status" in str(i).lower()]

        assert len(status_issues) > 0, (
            f"Validator should flag missing 'status' on project type. "
            f"Got issues: {missing_issues}"
        )

    def test_validator_allows_optional_properties(self, tmp_path: Path) -> None:
        """Test that validator doesn't require optional properties."""
        init_vault(tmp_path, "para", dry_run=False, use_defaults=True)

        # Create a project note WITH status but without optional 'deadline'
        project_note = tmp_path / "Projects" / "test_project.md"
        project_note.write_text("""---
type: project
up: "[[Projects]]"
created: 2024-01-01
tags: []
status: active
---
# Test Project
""")

        # Run validator
        validator = VaultValidator(str(tmp_path))
        validator.run_validation()

        # Should NOT have issues about missing 'deadline'
        missing_issues = validator.issues.get("missing_properties", [])
        deadline_issues = [i for i in missing_issues if "deadline" in str(i).lower()]

        assert len(deadline_issues) == 0, (
            f"Validator should not require optional 'deadline' property. "
            f"Got issues: {missing_issues}"
        )
