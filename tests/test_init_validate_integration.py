"""
Integration tests: init + validate workflow

These tests ensure that:
1. init skill generates valid settings.yaml that settings_loader can parse
2. Sample notes generated by init pass validation
3. All methodologies work end-to-end

Run with: uv run pytest tests/test_init_validate_integration.py -v
"""

import sys
from pathlib import Path

import pytest

# Add paths for imports
sys.path.insert(0, str(Path(__file__).parent.parent / "skills" / "init" / "scripts"))
sys.path.insert(0, str(Path(__file__).parent.parent / "skills" / "validate" / "scripts"))
sys.path.insert(0, str(Path(__file__).parent.parent / "skills" / "config" / "scripts"))

from init_vault import (
    METHODOLOGIES,
    FOLDER_DESCRIPTIONS,
    init_vault,
    generate_template_note,
    create_template_notes,
    get_content_folders,
    get_all_content_folders,
    generate_all_bases_content,
    create_all_bases_file,
    generate_folder_readme_content,
    create_folder_readmes,
)
from settings_loader import load_settings
from validator import VaultValidator


class TestInitGeneratesValidSettings:
    """Test that init generates settings.yaml that settings_loader can parse."""

    @pytest.mark.parametrize("methodology", list(METHODOLOGIES.keys()))
    def test_init_settings_loadable(self, tmp_path: Path, methodology: str) -> None:
        """Test that settings.yaml from init can be loaded by settings_loader."""
        # Initialize vault
        init_vault(tmp_path, methodology, dry_run=False, use_defaults=True)

        # Verify settings.yaml exists
        settings_file = tmp_path / ".claude" / "settings.yaml"
        assert settings_file.exists(), f"settings.yaml not created for {methodology}"

        # Load settings - this should not raise
        settings = load_settings(tmp_path)

        # Verify basic structure
        assert settings.methodology == methodology
        assert len(settings.core_properties) > 0, "core_properties should not be empty"
        assert len(settings.note_types) > 0, "note_types should not be empty"

    @pytest.mark.parametrize("methodology", list(METHODOLOGIES.keys()))
    def test_core_properties_are_list(self, tmp_path: Path, methodology: str) -> None:
        """Test that core_properties is parsed as a list, not a dict."""
        init_vault(tmp_path, methodology, dry_run=False, use_defaults=True)
        settings = load_settings(tmp_path)

        # This was a bug: core_properties was {'all': [...]} instead of [...]
        assert isinstance(settings.core_properties, list), (
            f"core_properties should be list, got {type(settings.core_properties)}"
        )
        assert all(isinstance(p, str) for p in settings.core_properties), (
            "All core_properties should be strings"
        )

    @pytest.mark.parametrize("methodology", list(METHODOLOGIES.keys()))
    def test_note_types_have_required_properties(
        self, tmp_path: Path, methodology: str
    ) -> None:
        """Test that each note type has required_properties that include core."""
        init_vault(tmp_path, methodology, dry_run=False, use_defaults=True)
        settings = load_settings(tmp_path)

        for name, note_type in settings.note_types.items():
            # Each note type should have required_properties
            assert hasattr(note_type, "required_properties"), (
                f"Note type {name} missing required_properties"
            )
            # Core properties should be included (if inherit_core is True)
            if note_type.inherit_core:
                for core_prop in settings.core_properties:
                    assert core_prop in note_type.required_properties, (
                        f"Note type {name} missing core property: {core_prop}"
                    )


class TestInitSampleNotesPassValidation:
    """Test that sample notes generated by init pass validation."""

    @pytest.mark.parametrize("methodology", list(METHODOLOGIES.keys()))
    def test_sample_notes_valid(self, tmp_path: Path, methodology: str) -> None:
        """Test that sample notes pass validation without errors."""
        # Initialize vault with sample notes
        init_vault(tmp_path, methodology, dry_run=False, use_defaults=True)

        # Run validator
        validator = VaultValidator(str(tmp_path))
        validator.run_validation()

        # Check for issues
        total_issues = sum(len(issues) for issues in validator.issues.values())

        if total_issues > 0:
            # Build helpful error message
            issue_details = []
            for issue_type, issues in validator.issues.items():
                if issues:
                    issue_details.append(f"  {issue_type}: {issues}")

            pytest.fail(
                f"Validation failed for {methodology} with {total_issues} issues:\n"
                + "\n".join(issue_details)
            )

    @pytest.mark.parametrize("methodology", list(METHODOLOGIES.keys()))
    def test_no_missing_properties(self, tmp_path: Path, methodology: str) -> None:
        """Test that sample notes have all required properties."""
        init_vault(tmp_path, methodology, dry_run=False, use_defaults=True)

        validator = VaultValidator(str(tmp_path))
        validator.run_validation()

        missing = validator.issues.get("missing_properties", [])
        assert len(missing) == 0, (
            f"Sample notes for {methodology} have missing properties: {missing}"
        )

    @pytest.mark.parametrize("methodology", list(METHODOLOGIES.keys()))
    def test_no_empty_types(self, tmp_path: Path, methodology: str) -> None:
        """Test that sample notes have non-empty type fields."""
        init_vault(tmp_path, methodology, dry_run=False, use_defaults=True)

        validator = VaultValidator(str(tmp_path))
        validator.run_validation()

        empty_types = validator.issues.get("empty_types", [])
        assert len(empty_types) == 0, (
            f"Sample notes for {methodology} have empty types: {empty_types}"
        )


class TestSettingsLoaderFormats:
    """Test that settings_loader handles different settings.yaml formats."""

    def test_nested_core_properties_format(self, tmp_path: Path) -> None:
        """Test handling of nested core_properties: {all: [...], mandatory: [...]}."""
        settings_dir = tmp_path / ".claude"
        settings_dir.mkdir(parents=True)

        # Write settings with nested format (as generated by init)
        settings_file = settings_dir / "settings.yaml"
        settings_file.write_text("""
version: '1.0'
methodology: para
core_properties:
  all:
    - type
    - up
    - created
    - tags
  mandatory:
    - type
    - up
  optional:
    - tags
note_types:
  project:
    description: Test
    folder_hints:
      - Projects/
    properties:
      additional_required:
        - status
""")

        settings = load_settings(tmp_path)

        # Verify core_properties is a list, not a dict
        assert isinstance(settings.core_properties, list)
        assert settings.core_properties == ["type", "up", "created", "tags"]

    def test_flat_core_properties_format(self, tmp_path: Path) -> None:
        """Test handling of flat core_properties: [...]."""
        settings_dir = tmp_path / ".claude"
        settings_dir.mkdir(parents=True)

        # Write settings with flat format (backwards compatible)
        settings_file = settings_dir / "settings.yaml"
        settings_file.write_text("""
version: '1.0'
methodology: custom
core_properties:
  - type
  - up
  - created
note_types:
  note:
    description: Test
    folder_hints: []
    properties:
      additional_required: []
""")

        settings = load_settings(tmp_path)

        # Verify core_properties is a list
        assert isinstance(settings.core_properties, list)
        assert settings.core_properties == ["type", "up", "created"]


class TestValidatorUsesSettings:
    """Test that validator correctly uses settings from settings.yaml."""

    def test_validator_loads_settings(self, tmp_path: Path) -> None:
        """Test that validator loads and uses settings.yaml."""
        init_vault(tmp_path, "para", dry_run=False, use_defaults=True)

        validator = VaultValidator(str(tmp_path))

        # Validator should have loaded settings
        assert validator.settings is not None
        assert validator.settings.methodology == "para"

    def test_validator_uses_core_properties_from_settings(
        self, tmp_path: Path
    ) -> None:
        """Test that validator uses core_properties from settings.yaml."""
        init_vault(tmp_path, "minimal", dry_run=False, use_defaults=True)

        validator = VaultValidator(str(tmp_path))
        settings = load_settings(tmp_path)

        # Validator's required_properties should match settings
        assert validator.required_properties == settings.core_properties


class TestResetAndReinitialize:
    """Test reset and re-initialization workflow."""

    def test_reset_then_different_methodology(self, tmp_path: Path) -> None:
        """Test initializing with one methodology, reset, then another."""
        # First init with lyt-ace
        init_vault(tmp_path, "lyt-ace", dry_run=False, use_defaults=True)
        settings1 = load_settings(tmp_path)
        assert settings1.methodology == "lyt-ace"

        # Reset (manually clear and re-init)
        # In real usage, reset_vault would be called
        import shutil
        for item in tmp_path.iterdir():
            if item.name != ".obsidian":
                if item.is_dir():
                    shutil.rmtree(item)
                else:
                    item.unlink()

        # Re-init with para
        init_vault(tmp_path, "para", dry_run=False, use_defaults=True)
        settings2 = load_settings(tmp_path)
        assert settings2.methodology == "para"

        # Validate should pass
        validator = VaultValidator(str(tmp_path))
        validator.run_validation()
        total_issues = sum(len(issues) for issues in validator.issues.values())
        assert total_issues == 0, f"Validation failed after reset: {validator.issues}"


class TestTemplateGeneration:
    """Test that init generates template notes for each note type."""

    @pytest.mark.parametrize("methodology", list(METHODOLOGIES.keys()))
    def test_templates_created(self, tmp_path: Path, methodology: str) -> None:
        """Test that template files are created for each note type."""
        init_vault(tmp_path, methodology, dry_run=False, use_defaults=True)

        method_config = METHODOLOGIES[methodology]
        folder_structure = method_config.get("folder_structure", {})
        templates_folder = folder_structure.get("templates", "x/templates/")
        templates_path = tmp_path / templates_folder

        # Get expected note types (excluding daily)
        note_types = method_config.get("note_types", {})
        expected_templates = [nt for nt in note_types.keys() if nt != "daily"]

        # Check templates exist
        assert templates_path.exists(), f"Templates folder not created for {methodology}"

        for note_type in expected_templates:
            template_file = templates_path / f"{note_type}.md"
            assert template_file.exists(), (
                f"Template for {note_type} not created in {methodology}"
            )

    @pytest.mark.parametrize("methodology", list(METHODOLOGIES.keys()))
    def test_templates_have_valid_frontmatter(
        self, tmp_path: Path, methodology: str
    ) -> None:
        """Test that template files have valid frontmatter structure."""
        init_vault(tmp_path, methodology, dry_run=False, use_defaults=True)

        method_config = METHODOLOGIES[methodology]
        folder_structure = method_config.get("folder_structure", {})
        templates_folder = folder_structure.get("templates", "x/templates/")
        templates_path = tmp_path / templates_folder
        core_properties = method_config.get("core_properties", [])

        for template_file in templates_path.glob("*.md"):
            content = template_file.read_text()

            # Check frontmatter structure
            assert content.startswith("---"), (
                f"Template {template_file.name} missing frontmatter start"
            )
            assert content.count("---") >= 2, (
                f"Template {template_file.name} missing frontmatter end"
            )

            # Extract frontmatter
            parts = content.split("---", 2)
            frontmatter = parts[1]

            # Check that all core properties are present
            for prop in core_properties:
                assert f"{prop}:" in frontmatter, (
                    f"Template {template_file.name} missing {prop} property"
                )

    def test_template_has_type_specific_properties(self, tmp_path: Path) -> None:
        """Test that templates include type-specific required properties."""
        init_vault(tmp_path, "lyt-ace", dry_run=False, use_defaults=True)

        # Check source template has author and url
        source_template = tmp_path / "x" / "templates" / "source.md"
        content = source_template.read_text()
        assert "author:" in content, "Source template missing author property"
        assert "url:" in content, "Source template missing url property"

        # Check project template has status
        project_template = tmp_path / "x" / "templates" / "project.md"
        content = project_template.read_text()
        assert "status:" in content, "Project template missing status property"

    def test_template_has_optional_properties_as_comments(
        self, tmp_path: Path
    ) -> None:
        """Test that optional properties are included as comments."""
        init_vault(tmp_path, "lyt-ace", dry_run=False, use_defaults=True)

        # Check project template has optional properties as comments
        project_template = tmp_path / "x" / "templates" / "project.md"
        content = project_template.read_text()
        assert "# deadline:" in content, "Project template missing deadline comment"
        assert "# priority:" in content, "Project template missing priority comment"

    def test_generate_template_note_structure(self) -> None:
        """Test the generate_template_note function output structure."""
        type_config = {
            "description": "Test note type",
            "properties": {
                "additional_required": ["status", "priority"],
                "optional": ["deadline"],
            },
        }
        core_properties = ["type", "up", "created", "tags"]

        content = generate_template_note("test", type_config, core_properties)

        # Check structure
        assert content.startswith("---")
        assert 'type: "test"' in content
        assert 'up: "[[]]"' in content
        assert "created: {{date}}" in content
        assert "tags: []" in content
        assert "status:" in content
        assert "priority:" in content
        assert "# deadline:" in content
        assert "{{title}}" in content


class TestAllBasesFileGeneration:
    """Test that init generates all_bases.base for Obsidian Bases plugin."""

    @pytest.mark.parametrize("methodology", list(METHODOLOGIES.keys()))
    def test_all_bases_file_created(self, tmp_path: Path, methodology: str) -> None:
        """Test that all_bases.base file is created."""
        init_vault(tmp_path, methodology, dry_run=False, use_defaults=True)

        base_file = tmp_path / "x" / "bases" / "all_bases.base"
        assert base_file.exists(), f"all_bases.base not created for {methodology}"

    @pytest.mark.parametrize("methodology", list(METHODOLOGIES.keys()))
    def test_all_bases_has_global_filters(self, tmp_path: Path, methodology: str) -> None:
        """Test that all_bases.base has correct global filters."""
        init_vault(tmp_path, methodology, dry_run=False, use_defaults=True)

        base_file = tmp_path / "x" / "bases" / "all_bases.base"
        content = base_file.read_text()

        # Check global filters
        assert 'file.inFolder("+")' in content, "Missing + folder exclusion"
        assert 'file.inFolder("x")' in content, "Missing x folder exclusion"
        assert 'file.folder != "/"' in content, "Missing root files exclusion"

    @pytest.mark.parametrize("methodology", list(METHODOLOGIES.keys()))
    def test_all_bases_has_all_view_grouped(self, tmp_path: Path, methodology: str) -> None:
        """Test that all_bases.base has All view grouped by folder."""
        init_vault(tmp_path, methodology, dry_run=False, use_defaults=True)

        base_file = tmp_path / "x" / "bases" / "all_bases.base"
        content = base_file.read_text()

        # Check All view exists with groupBy
        assert "name: All" in content, "Missing All view"
        assert "groupBy:" in content, "All view should have groupBy"
        assert "file.folder" in content, "All view should group by file.folder"

    def test_para_has_four_folder_views(self, tmp_path: Path) -> None:
        """Test PARA methodology creates views for Projects, Areas, Resources, Archives."""
        init_vault(tmp_path, "para", dry_run=False, use_defaults=True)

        base_file = tmp_path / "x" / "bases" / "all_bases.base"
        content = base_file.read_text()

        # Check folder-specific views
        expected_folders = ["Projects", "Areas", "Resources", "Archives"]
        for folder in expected_folders:
            assert f'name: {folder}' in content, f"Missing {folder} view"
            assert f'file.inFolder("{folder}")' in content, f"Missing {folder} filter"

    def test_lyt_ace_has_top_level_views(self, tmp_path: Path) -> None:
        """Test LYT-ACE creates views for Atlas, Calendar, Efforts (top-level)."""
        init_vault(tmp_path, "lyt-ace", dry_run=False, use_defaults=True)

        base_file = tmp_path / "x" / "bases" / "all_bases.base"
        content = base_file.read_text()

        # Check top-level folder views
        expected_folders = ["Atlas", "Calendar", "Efforts"]
        for folder in expected_folders:
            assert f'name: {folder}' in content, f"Missing {folder} view"
            assert f'file.inFolder("{folder}")' in content, f"Missing {folder} filter"

    def test_folder_views_have_no_groupby(self, tmp_path: Path) -> None:
        """Test folder-specific views don't have groupBy (flat listing)."""
        init_vault(tmp_path, "para", dry_run=False, use_defaults=True)

        base_file = tmp_path / "x" / "bases" / "all_bases.base"
        content = base_file.read_text()

        # Parse views - All should have groupBy, others shouldn't
        # Count occurrences - should be exactly 1 (for All view)
        assert content.count("groupBy:") == 1, "Only All view should have groupBy"


class TestFolderReadmeGeneration:
    """Test that init generates _Readme.md (MOC) files in each content folder."""

    @pytest.mark.parametrize("methodology", list(METHODOLOGIES.keys()))
    def test_folder_readmes_created(self, tmp_path: Path, methodology: str) -> None:
        """Test that _Readme.md files are created in each content folder."""
        init_vault(tmp_path, methodology, dry_run=False, use_defaults=True)

        content_folders = get_content_folders(methodology)
        for folder in content_folders:
            readme_file = tmp_path / folder / "_Readme.md"
            assert readme_file.exists(), f"_Readme.md not created in {folder}"

    @pytest.mark.parametrize("methodology", list(METHODOLOGIES.keys()))
    def test_folder_readmes_have_map_type(self, tmp_path: Path, methodology: str) -> None:
        """Test that _Readme.md files have type: map in frontmatter."""
        init_vault(tmp_path, methodology, dry_run=False, use_defaults=True)

        content_folders = get_content_folders(methodology)
        for folder in content_folders:
            readme_file = tmp_path / folder / "_Readme.md"
            content = readme_file.read_text()
            assert 'type: map' in content, f"_Readme.md in {folder} missing type: map"

    @pytest.mark.parametrize("methodology", list(METHODOLOGIES.keys()))
    def test_folder_readmes_embed_base_view(self, tmp_path: Path, methodology: str) -> None:
        """Test that _Readme.md files embed the correct base view."""
        init_vault(tmp_path, methodology, dry_run=False, use_defaults=True)

        content_folders = get_content_folders(methodology)
        for folder in content_folders:
            readme_file = tmp_path / folder / "_Readme.md"
            content = readme_file.read_text()
            expected_embed = f"![[all_bases.base#{folder}]]"
            assert expected_embed in content, (
                f"_Readme.md in {folder} missing embed: {expected_embed}"
            )

    def test_para_folder_descriptions(self, tmp_path: Path) -> None:
        """Test PARA folders have correct descriptions."""
        init_vault(tmp_path, "para", dry_run=False, use_defaults=True)

        # Check Projects description
        projects_readme = tmp_path / "Projects" / "_Readme.md"
        content = projects_readme.read_text()
        assert "Active projects with defined outcomes" in content

        # Check Archives description
        archives_readme = tmp_path / "Archives" / "_Readme.md"
        content = archives_readme.read_text()
        assert "Completed or inactive items" in content

    def test_lyt_ace_folder_descriptions(self, tmp_path: Path) -> None:
        """Test LYT-ACE folders have correct descriptions."""
        init_vault(tmp_path, "lyt-ace", dry_run=False, use_defaults=True)

        # Check Atlas description
        atlas_readme = tmp_path / "Atlas" / "_Readme.md"
        content = atlas_readme.read_text()
        assert "Knowledge repository" in content

        # Check Efforts description
        efforts_readme = tmp_path / "Efforts" / "_Readme.md"
        content = efforts_readme.read_text()
        assert "Active work including projects" in content

    def test_lyt_ace_subfolders_have_readmes(self, tmp_path: Path) -> None:
        """Test LYT-ACE subfolders (Dots, Maps, Sources, etc.) have _Readme.md."""
        init_vault(tmp_path, "lyt-ace", dry_run=False, use_defaults=True)

        # Check subfolders have readmes
        subfolders = ["Atlas/Dots", "Atlas/Maps", "Atlas/Sources",
                      "Efforts/Projects", "Efforts/Areas", "Calendar/daily"]
        for folder in subfolders:
            readme_file = tmp_path / folder / "_Readme.md"
            assert readme_file.exists(), f"_Readme.md not created in {folder}"

    def test_subfolder_readme_embeds_subfolder_view(self, tmp_path: Path) -> None:
        """Test subfolder _Readme.md embeds its own folder view."""
        init_vault(tmp_path, "lyt-ace", dry_run=False, use_defaults=True)

        # Atlas/Dots should embed ![[all_bases.base#Dots]] (subfolder-specific view)
        dots_readme = tmp_path / "Atlas" / "Dots" / "_Readme.md"
        content = dots_readme.read_text()
        assert "![[all_bases.base#Dots]]" in content

        # Efforts/Projects should embed #Projects
        projects_readme = tmp_path / "Efforts" / "Projects" / "_Readme.md"
        content = projects_readme.read_text()
        assert "![[all_bases.base#Projects]]" in content

    def test_all_bases_excludes_map_type(self, tmp_path: Path) -> None:
        """Test all_bases.base has filter to exclude map type."""
        init_vault(tmp_path, "para", dry_run=False, use_defaults=True)

        base_file = tmp_path / "x" / "bases" / "all_bases.base"
        content = base_file.read_text()
        assert 'type != "map"' in content, "Missing map type exclusion filter"

    def test_all_bases_has_subfolder_views(self, tmp_path: Path) -> None:
        """Test all_bases.base has views for subfolders (LYT-ACE)."""
        init_vault(tmp_path, "lyt-ace", dry_run=False, use_defaults=True)

        base_file = tmp_path / "x" / "bases" / "all_bases.base"
        content = base_file.read_text()

        # Check subfolder views exist with correct filters
        assert "name: Dots" in content, "Missing Dots view"
        assert 'file.inFolder("Atlas/Dots")' in content, "Dots view has wrong filter"
        assert "name: Projects" in content, "Missing Projects view"
        assert 'file.inFolder("Efforts/Projects")' in content, "Projects view has wrong filter"


class TestAutoResetOnMethodologyChange:
    """Test that vault auto-resets when methodology changes."""

    def test_auto_reset_removes_old_folders(self, tmp_path: Path) -> None:
        """Test switching methodology removes old folders."""
        # Init with PARA
        init_vault(tmp_path, "para", dry_run=False, use_defaults=True)
        assert (tmp_path / "Projects").exists()
        assert (tmp_path / "Archives").exists()

        # Switch to LYT-ACE - should auto-reset
        init_vault(tmp_path, "lyt-ace", dry_run=False, use_defaults=True)

        # Old PARA folders should be gone
        assert not (tmp_path / "Projects").exists(), "Projects folder should be removed"
        assert not (tmp_path / "Archives").exists(), "Archives folder should be removed"

        # New LYT folders should exist
        assert (tmp_path / "Atlas").exists()
        assert (tmp_path / "Efforts").exists()

    def test_same_methodology_no_reset(self, tmp_path: Path) -> None:
        """Test re-init with same methodology doesn't reset."""
        # Init with PARA
        init_vault(tmp_path, "para", dry_run=False, use_defaults=True)

        # Create a custom file
        custom_file = tmp_path / "Projects" / "my_project.md"
        custom_file.write_text("# My Project\n")

        # Re-init with same methodology
        init_vault(tmp_path, "para", dry_run=False, use_defaults=True)

        # Custom file should still exist
        assert custom_file.exists(), "Custom file should not be deleted"
